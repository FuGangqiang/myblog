created: 2011-01-23T01:44:00+08:00
tags: [linux]

看了一篇论坛讨论，介绍的挺清晰的，转一下 :-)

```
#include <unistd.h>;
#include <sys/types.h>;
 
main ()
{
       pid_t pid;
       pid=fork();
 
       if (pid < 0)
            printf("error in fork!");
       else if (pid == 0)
            printf("i am the child process, my process id is %d\n",getpid());
       else
            printf("i am the parent process, my process id is %d\n",getpid());
}
```

运行结果是：

```
[root@localhost c]# ./a.out
i am the child process, my process id is 4286
i am the parent process, my process id is 4285
```

问题：
为什么两行都打印出来了，不管pid是多少，都应该只有一行才对？

回答：
要搞清楚fork的执行过程，就必须先讲清楚操作系统中的“进程(process)”概念。一个进程，主要包含三个元素：
 
* 一个可以执行的程序；
* 和该进程相关联的全部数据（包括变量，内存空间，缓冲区等等）；
* 程序的执行上下文（execution context）。

不妨简单理解为，一个进程表示的，就是一个可执行程序的一次执行过程中的一个状态。
操作系统对进程的管理，典型的情况，是通过进程表完成的。进程表中的每 一个表项，记录的是当前操作系统中一个进程的情况。
对于单 CPU的情况而言，每一特定时刻只有一个进程占用 CPU，但是系统中可能同时存在多个活动的（等待执行或继续执行的）进程。
 
一个称为“程序计数器（program counter, pc）”的寄存器，指出当前占用 CPU的进程要执行的下一条指令的位置。
 
当分给某个进程的 CPU时间已经用完，操作系统将该进程相关的寄存器的值，保存到该进程在进程表中对应的表项里面；
把将要接替这个进程占用 CPU的那个进程的上下文，从进程表中读出，
并更新相应的寄存器（这个过程称为“上下文交换(process context switch)”，
实际的上下文交换需要涉及到更多的数据，那和fork无关，不再多说，
主要要记住程序寄存器pc指出程序当前已经执行到哪里，是进程上 下文的重要内容，
换出 CPU的进程要保存这个寄存器的值，换入CPU的进程，也要根据进程表中保存的本进程执行上下文信息，更新这个寄存器）。
 
好了，有这些概念打底，可以说fork了。当你的程序执行到下面的语句：

```
pid=fork(); 
```

操作系统创建一个新的进程（子进程），并且在进程表中相应为它建立一个新的表项。
新进程和原有进程的可执行程序是同一个程序；
上下文和数据，绝大部分就是 原进程（父进程）的拷贝，但它们是两个相互独立的进程！
此时程序寄存器pc，在父、子进程的上下文中都声称，这个进程目前执行到fork调用即将返回
（此时子进程不占有CPU，子进程的pc不是真正保存在寄存器中，而是作为进程上下文保存在进程表中的对应表项内）。
问题是怎么返回，在父子进程中就分道扬镳。
 
父进程继续执行，操作系统对fork的实现，使这个调用在父进程中返回刚刚创建的子进程的pid（一个正整数），
所以下面的if语句中pid<0, pid==0的两个分支都不会执行。
所以输出`i am the parent process...`
 
子进程在之后的某个时候得到调度，它的上下文被换入，占据 CPU，操作系统对fork的实现，使得子进程中fork调用返回0。
所以在这个进程（注意这不是父进程了哦，虽然是同一个程序，但是这是同一个程序的另外一次执行，
在操作系统中这次执行是由另外一个进程表示的，从执行的角度说和父进程相互独立）中pid=0。
这个进程继续执行的过程中，if语句中 pid<0不满足，但是pid==0是true。
所以输出`i am the child process...`
 
我想你比较困惑的就是，为什么看上去程序中互斥的两个分支都被执行了。
在一个程序的一次执行中，这当然是不可能的；但是你看到的两行输出是来自两个进程，这两个进程来自同一个程序的两次执行。

我的天，不知道说明白了没……

原帖：[http://bbs.chinaunix.net/thread-311067-1-1.html]().